// Instru√ß√£o para n√£o modificar ou excluir este script, a menos que voc√™ saiba o que est√° fazendo.
// Este script gera o arquivo contendo as defini√ß√µes dos ABIs dos contratos.
// Essas defini√ß√µes s√£o usadas para derivar os tipos necess√°rios nos hooks personalizados do Scaffold-ETH, por exemplo.
// Este script deve ser executado como o √∫ltimo script de deploy.

// Importa o m√≥dulo de sistema de arquivos do Node.js.
import * as fs from "fs";
// Importa a biblioteca Prettier para formatar o c√≥digo gerado.
import prettier from "prettier";
// Importa o tipo DeployFunction de hardhat-deploy/types.
import { DeployFunction } from "hardhat-deploy/types";

// Coment√°rio gerado que ser√° adicionado ao topo do arquivo gerado, avisando que √© um arquivo autogerado.
const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

// Define os diret√≥rios onde os deployments e artifacts s√£o armazenados.
const DEPLOYMENTS_DIR = "./deployments";
const ARTIFACTS_DIR = "./artifacts";

// Fun√ß√£o para obter os diret√≥rios dentro de um caminho especificado.
function getDirectories(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true }) // L√™ o diret√≥rio.
    .filter(dirent => dirent.isDirectory()) // Filtra apenas os diret√≥rios.
    .map(dirent => dirent.name); // Retorna os nomes dos diret√≥rios.
}

// Fun√ß√£o para obter os nomes dos contratos a partir dos arquivos JSON em um diret√≥rio.
function getContractNames(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true }) // L√™ o diret√≥rio.
    .filter(dirent => dirent.isFile() && dirent.name.endsWith(".json")) // Filtra apenas os arquivos JSON.
    .map(dirent => dirent.name.split(".")[0]); // Retorna os nomes dos contratos, removendo a extens√£o .json.
}

// Fun√ß√£o para obter as fontes reais de um contrato, baseando-se nos contratos dos quais ele herda.
function getActualSourcesForContract(sources: Record<string, any>, contractName: string) {
  // Itera sobre os caminhos das fontes.
  for (const sourcePath of Object.keys(sources)) {
    const sourceName = sourcePath.split("/").pop()?.split(".sol")[0];
    if (sourceName === contractName) {
      const contractContent = sources[sourcePath].content as string;
      const regex = /contract\s+(\w+)\s+is\s+([^{}]+)\{/;
      const match = contractContent.match(regex);

      if (match) {
        const inheritancePart = match[2];
        // Divide os contratos herdados por v√≠rgulas para obter a lista de contratos herdados.
        const inheritedContracts = inheritancePart.split(",").map(contract => `${contract.trim()}.sol`);

        return inheritedContracts;
      }
      return [];
    }
  }
  return [];
}

// Fun√ß√£o para obter as fun√ß√µes herdadas de contratos.
function getInheritedFunctions(sources: Record<string, any>, contractName: string) {
  const actualSources = getActualSourcesForContract(sources, contractName);
  const inheritedFunctions = {} as Record<string, any>;

  // Itera sobre os contratos-fonte reais.
  for (const sourceContractName of actualSources) {
    const sourcePath = Object.keys(sources).find(key => key.includes(`/${sourceContractName}`));
    if (sourcePath) {
      const sourceName = sourcePath?.split("/").pop()?.split(".sol")[0];
      // L√™ o ABI do contrato-fonte.
      const { abi } = JSON.parse(fs.readFileSync(`${ARTIFACTS_DIR}/${sourcePath}/${sourceName}.json`).toString());
      // Itera sobre as fun√ß√µes do ABI, adicionando-as ao objeto de fun√ß√µes herdadas.
      for (const functionAbi of abi) {
        if (functionAbi.type === "function") {
          inheritedFunctions[functionAbi.name] = sourcePath;
        }
      }
    }
  }

  return inheritedFunctions;
}

// Fun√ß√£o para obter os dados dos contratos a partir dos deployments.
function getContractDataFromDeployments() {
  if (!fs.existsSync(DEPLOYMENTS_DIR)) {
    throw Error("At least one other deployment script should exist to generate an actual contract.");
  }
  // Se o diret√≥rio de deployments n√£o existir, lan√ßa um erro indicando que pelo menos um script de deploy deve ser executado antes deste.

  const output = {} as Record<string, any>;
  // Inicializa um objeto para armazenar os dados dos contratos de cada rede.
  
  for (const chainName of getDirectories(DEPLOYMENTS_DIR)) {
    // Itera sobre cada rede (diret√≥rio) dentro do diret√≥rio de deployments.
    
    const chainId = fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/.chainId`).toString();
    // L√™ o ID da cadeia para a rede atual.
    
    const contracts = {} as Record<string, any>;
    // Inicializa um objeto para armazenar os dados dos contratos nesta rede.
    
    for (const contractName of getContractNames(`${DEPLOYMENTS_DIR}/${chainName}`)) {
      // Itera sobre cada contrato dentro do diret√≥rio da rede.
      
      const { abi, address, metadata } = JSON.parse(
        fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/${contractName}.json`).toString(),
      );
      // L√™ os dados do contrato, incluindo ABI, endere√ßo e metadados.
      
      const inheritedFunctions = getInheritedFunctions(JSON.parse(metadata).sources, contractName);
      // Obt√©m as fun√ß√µes herdadas do contrato.
      
      contracts[contractName] = { address, abi, inheritedFunctions };
      // Armazena os dados do contrato no objeto de contratos.
    }
    output[chainId] = contracts;
    // Associa os contratos √† ID da cadeia no objeto de sa√≠da.
  }
  return output;
  // Retorna o objeto contendo os dados dos contratos organizados por ID da cadeia.
}

/**
 * Gera o arquivo de defini√ß√£o TypeScript dos contratos com base na sa√≠da JSON dos scripts de deploy dos contratos.
 * Este script deve ser executado por √∫ltimo.
 */
const generateTsAbis: DeployFunction = async function () {
  const TARGET_DIR = "../nextjs/contracts/";
  // Define o diret√≥rio alvo onde o arquivo ser√° gerado.
  
  const allContractsData = getContractDataFromDeployments();
  // Obt√©m os dados de todos os contratos implantados.
  
  const fileContent = Object.entries(allContractsData).reduce((content, [chainId, chainConfig]) => {
    return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(chainConfig, null, 2)},`;
  }, "");
  // Formata os dados dos contratos em uma string para ser inserida no arquivo.
  
  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR);
    // Se o diret√≥rio alvo n√£o existir, cria-o.
  }
  fs.writeFileSync(
    `${TARGET_DIR}deployedContracts.ts`,
    prettier.format(
      `${generatedContractComment} import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract"; \n\n
 const deployedContracts = {${fileContent}} as const; \n\n export default deployedContracts satisfies GenericContractsDeclaration`,
      {
        parser: "typescript",
      },
    ),
  );
  // Escreve o conte√∫do formatado no arquivo TypeScript de defini√ß√£o dos contratos.

  console.log(`üìù Updated TypeScript contract definition file on ${TARGET_DIR}deployedContracts.ts`);
  // Exibe uma mensagem no console indicando que o arquivo foi atualizado.
};

export default generateTsAbis;
// Exporta a fun√ß√£o para que possa ser executada como parte dos scripts de deploy.

// Define tags para o script, permitindo sua execu√ß√£o seletiva com o comando espec√≠fico.
generateTsAbis.tags = ["generateTsAbis"];

// Indica que este script deve ser executado por √∫ltimo.
generateTsAbis.runAtTheEnd = true;
